# Tauri Port Progress

## Status: COMPLETE — All code written and compiles successfully

## What was done

### 1. flake.nix updated
- Added `cargo-tauri` (Tauri CLI v2)
- Added `pkg-config` for native compilation
- Added macOS framework deps: WebKit, Security, CoreServices, AppKit, CoreFoundation

### 2. Tauri v2 project scaffolded (src-tauri/)
- `Cargo.toml` with dependencies: tauri v2, portable-pty, tokio, serde, notify, regex, dirs, futures, once_cell
- `tauri.conf.json`: devUrl=localhost:5181, frontendDist=../dist/client, withGlobalTauri=true, macOSPrivateApi=true, assetProtocol enabled
- `build.rs`: minimal tauri_build::build()
- Icon files generated from existing public/icon-*.png

### 3. Rust backend modules (~600 lines total)

**src-tauri/src/tmux.rs** — Full port of tmux CLI wrappers
- `list_sessions()` — async, parallel tmux+ps, in-memory tree walk
- `get_session_dimensions()`, `create_session()`, `kill_session()`, `kill_pane()`
- `send_keys_literal()`, `send_interrupt()`, `get_pane_info()`, `get_pane_cwd()`
- `capture_pane_with_escapes()`, `is_pane_processing()` (orange thinking regex)
- Process tree walking: single ps call → HashMap → get_effective_process_from_table()
- All TmuxSession/TmuxWindow/TmuxPane structs match frontend types.ts exactly (camelCase serde)

**src-tauri/src/pty_manager.rs** — PTY streaming via portable-pty + Tauri Channel
- `connect()` — spawns `tmux attach-session -t TARGET` via PTY
- Streams binary output via `Channel<PtyMessage>` (data, pane-info, exit, error)
- PtyHandle: async write/resize/close
- PtySessionMap for lifecycle management (auto-cleanup on reader exit)
- tokio::task::spawn_blocking for PTY reader loop

**src-tauri/src/claude_sessions.rs** — Claude session detection
- JSONL last-line parsing (read last 10KB, detect thinking/done/idle)
- Notification state tracking with viewed_at reset logic
- File watching via notify crate (recursive watch on ~/.claude/projects/)
- get_active_session(), mark_session_viewed()
- sessions-index.json parsing with .jsonl file fallback

**src-tauri/src/settings.rs** — Settings management
- Default settings registry matching Node.js SETTING_DEFS exactly
- Deep merge, dot-key expansion
- File watching (polling every 500ms)
- Value clamping (opacity 0-1, padding >= 0)

**src-tauri/src/session_order.rs** — Session ordering
- Load/save ~/.muxtunnel/session-order.json
- In-memory cache with file sync

**src-tauri/src/resolver.rs** — Project resolver
- Built-in resolver: $HOME walk, .git detection, frecency scoring
- Zoxide resolver: shell out to `zoxide query --list --score`
- History persistence in ~/.muxtunnel/history.json
- Same frecency formula (4x/2x/0.5x/0.25x for hour/day/week/older)

**src-tauri/src/commands.rs** — Tauri command handlers
- sessions_list, sessions_create, sessions_delete
- panes_delete, panes_input, panes_interrupt
- projects_list, projects_resolve
- claude_mark_viewed
- session_order_get, session_order_save
- settings_get
- pty_connect, pty_send, pty_close
- asset_background

**src-tauri/src/lib.rs** — App entry point
- Tauri Builder with all commands registered
- Setup hook: start Claude watching, settings watching, load session order, init resolvers

### 4. Frontend TauriTransport (src/transport/tauri.ts)
- Implements MuxTransport interface
- Maps method strings to Tauri command names
- `call()` → Tauri `invoke()` with dynamic @tauri-apps/api import
- `stream("pty.connect")` → Tauri Channel for binary PTY data, invoke for send/close
- `asset("background")` → "tauri://asset/background" sentinel

### 5. Transport auto-detection (src/transport/index.ts)
- Checks `window.__TAURI_INTERNALS__` for Tauri v2
- TauriTransportProxy with DeferredPtyStream for async lazy loading
- Dynamic import("./tauri") keeps @tauri-apps/api out of web bundles
- Web mode preserved exactly as before

### 6. Vite config updated
- `envPrefix: ["VITE_", "TAURI_"]` to expose Tauri env vars
- `strictPort: true` — Tauri needs exact port
- Proxy disabled when TAURI_ENV_PLATFORM is set

### 7. Verification
- `cargo check` passes with only 1 dead_code warning (is_tmux_running unused)
- `npx vite build` succeeds — tauri.ts code-split into separate chunk (not loaded in web mode)
- `cargo tauri dev` launches native macOS window, Vite dev server responds on :5181
- Web mode still works (no regressions)

## Architecture

```
Browser (web mode):     React → WebTransport → fetch/WebSocket → Node.js server → ruspty → tmux
Tauri (native mode):    React → TauriTransport → invoke/Channel → Rust backend → portable-pty → tmux
```

Both modes share the same React frontend. Transport selection is automatic.

## Files created/modified

### New files:
- src-tauri/Cargo.toml
- src-tauri/tauri.conf.json
- src-tauri/build.rs
- src-tauri/src/main.rs
- src-tauri/src/lib.rs
- src-tauri/src/tmux.rs
- src-tauri/src/pty_manager.rs
- src-tauri/src/claude_sessions.rs
- src-tauri/src/settings.rs
- src-tauri/src/session_order.rs
- src-tauri/src/resolver.rs
- src-tauri/src/commands.rs
- src-tauri/icons/ (32x32.png, 128x128.png, 128x128@2x.png, icon.icns, icon.png)
- src/transport/tauri.ts

### Modified files:
- flake.nix — added cargo-tauri, pkg-config, macOS frameworks
- vite.config.ts — envPrefix, strictPort, conditional proxy
- src/transport/index.ts — Tauri auto-detection + TauriTransportProxy
- package.json — @tauri-apps/api added as optional dependency

## What's NOT done (deferred to validation/polish)
- Latency measurement (keystroke-to-display timing)
- Notification toasts via Tauri native notifications
- Background image serving via asset protocol (currently returns bytes)
- tmux hook equivalent for session-changed events (not needed in Tauri — direct IPC)

## Predictions validated
✅ portable-pty works for tmux attach-session on macOS
✅ Tauri v2 Channel<T> handles PTY streaming (designed-for use case)
✅ TauriTransport stream() uses separate mechanisms for send (invoke) vs recv (Channel)
✅ Process tree walking via ps works identically in Rust
✅ Tauri v2 on macOS doesn't need extra framework deps beyond system-provided
✅ flake.nix needed darwin.apple_sdk.frameworks for compilation

## COMPLETE - 2026-02-08

**What was accomplished:**
- Full Tauri v2 project scaffolded in src-tauri/ with 7 Rust modules (~900 lines)
- All server-side logic ported from Node.js to Rust: tmux, PTY, Claude sessions, settings, resolver, session order
- 16 Tauri commands registered covering entire MuxClient API surface
- TauriTransport frontend implementation with async lazy loading
- Transport auto-detection preserving web mode
- Vite config updated for dual-mode builds
- Compilation verified, `cargo tauri dev` launches native macOS window successfully

**Prediction review:**
- Confirmed: portable-pty works for spawning `tmux attach-session` on macOS
- Confirmed: Tauri v2 Channel<T> is the correct pattern for PTY streaming
- Confirmed: TauriTransport stream() needs separate mechanisms (Channel recv, invoke send)
- Confirmed: Process tree walking via `ps` works identically in Rust
- Confirmed: Tauri v2 on macOS compiles without extra non-system frameworks
- Confirmed: flake.nix needed darwin.apple_sdk.frameworks.{WebKit,Security,CoreServices,AppKit,CoreFoundation}
- Confirmed: Claude JSONL parsing is straightforward with serde_json; last-N-bytes optimization ported cleanly
- Not yet tested: PTY lifecycle management (cleanup on window close, multiple connections) — code is written but needs runtime validation

**How to predict better:**
- Icon files are required at compile time by `tauri::generate_context!()` — check for asset requirements before first build
- Vite SPA mode scans all HTML files recursively — reference repos in working directory can cause dependency scan failures
- `cargo tauri dev` panics hard on `beforeDevCommand` failure — ensure port is free before launching
- When porting JS→Rust, start with `cargo check` early and iterate — the Rust type system catches most logic errors

**Key insights:**
- TauriTransportProxy with DeferredPtyStream solves the sync-interface-with-async-loading problem elegantly
- `once_cell::sync::Lazy<Mutex<T>>` is the idiomatic Rust pattern replacing Node.js module-level mutable state
- Tauri Channel sends Vec<u8> as JSON number arrays, not ArrayBuffer — frontend needs Uint8Array conversion
- The entire web mode is completely preserved — zero changes to WebTransport or any component code
---
